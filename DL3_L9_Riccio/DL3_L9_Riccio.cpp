// Author:                      Ryan Riccio
// Assignment Number:           Lab 9
// File Name:                   DL3_L9_Riccio.cpp
// Course/Section:              COSC 1337 Section DL3
// Due Date:                    November 10th, 2020
// Instructor:                  Thayer

#include <iostream>
#include <iomanip>
#include <random>

using namespace std;

const int TARGET = 123456789;
// TARGET cannot be found. It is larger than any random number
// generated by rand(), as desired to test for worst-case performance.

// array helper functions:
void showArray(int array[], int size, const string& msg = "") { // displays every element in array
    cout << msg;
    for (int i{}; i < size; ++i)
        cout << setw(2) << array[i]; // assumes small numbers
    cout << endl;
}

// Useful to verify that array is really sorted!
bool verifySorted(int array[], int size) {
    // returns true if array is in ascending order, else false.
    for (int i = 0; i < (size - 1); ++i)
        if (array[i] > array[i + 1]) return false;
    return true;
}

// Each selection sort below does the same algorithm. The
// difference is in how well it documents its operation.
void selectionSortConcise(int[], int);   // from internet, not called
void selectionSortTextBook(int[], int);  // from our textbook, not called
void selectionSort(int[], int, bool);    // as expected for this lab
void bubbleSort(int[], int, bool);
void insertionSort(int[], int, bool);

bool linearSearchArray(int[], int, int, int&);
bool binarySearchArray(int[], int, int, int&);

const int testSizes[] = { 1000, 5000, 10000, 20000, 30000, 40000, 50000, 0 };

// This code helps to automate multiple test runs.

// Call this code as many times as desired to test your sort algorithms.
float testSortAlgorithm(void sortAlgorithm(int[], int, bool),
    int array[], int arraySize, bool verbose = false) {
    // This function is interesting. The first parameter is a "function pointer",
    // It accepts any function that returns a void and has parameters of type: (int [], int, bool)
    // The first parameter (in the caller) can be the name of a function being tested.
    // This reduces redundant code. The same sequence of tests are performed on each
    // sort function. (Our textbook does not mention function pointers.)

    // fill array with random, unsorted numbers to be sorted
    for (int index = 0; index < arraySize; index++)
        array[index] = rand();  // initialize array with random values
    int startTime = clock();  // get the start time, in milliseconds
    sortAlgorithm(array, arraySize, verbose);  // ALGORITHM UNDER TEST
    int stopTime = clock();   // get the stop time, in milliseconds
    float duration = stopTime - startTime;
    if (!verifySorted(array, arraySize))
        duration = -duration; // return a negative duration to indicate sort failure
    return duration;
}

// Copy/paste/modify/reuse this code as desired to test search algorithms.
float testLinearSearch(int array[], int arraySize, int retry = 1000) {
    bool found = false; // true if TARGET is found in array
    int foundAt = 0;    // index in array where TARGET was found
    int startTime = clock();
    for (int repeat = 0; repeat < retry; ++repeat) // repeat test 1000 times to increase duration
        found = linearSearchArray(array, arraySize, TARGET, foundAt); // ALGORITHM UNDER TEST
    int stopTime = clock();
    float duration = stopTime - startTime;
    return duration / retry; // divide duration by 1000 to get time for single search
}

float testBinarySearch(int array[], int arraySize, int retry = 1000)
{
    bool found = false; // true if TARGET is found in array
    int foundAt = 0;    // index in array where TARGET was found
    int startTime = clock();
    for (int repeat = 0; repeat < retry; ++repeat) // repeat test 1000 times to increase duration
        found = binarySearchArray(array, arraySize, TARGET, foundAt); // ALGORITHM UNDER TEST
    int stopTime = clock();
    float duration = stopTime - startTime;
    return duration / retry; // divide duration by 1000 to get time for single search
}

void testAlgorithms(int array[], int arraySize, bool verbose = false) {
    // This draws a table of results for each algorithm tested.
    const int AlgorithmNameWidth = 16;
    const int TestSizeWidth = 10;
    const int DurationWidth = TestSizeWidth;
    cout << setw(AlgorithmNameWidth) << left << "Algorithm";
    for (int testCount = 0; testSizes[testCount]; ++testCount)
        cout << setw(TestSizeWidth) << right << testSizes[testCount];
    cout << endl << string(AlgorithmNameWidth, '=');
    for (int testCount = 0; testSizes[testCount]; ++testCount)
        cout << setw(DurationWidth) << right << " =======";

    // Copy and/or reuse this code as desired to test your algorithms.
    cout << endl << setw(AlgorithmNameWidth) << left << "selection sort";
    for (int testCount = 0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
        cout << setw(DurationWidth) << right << testSortAlgorithm(selectionSort, array, testSizes[testCount]);
    // In the line above, I am passing the name of the function selectionSort as a parameter into
    // the function testSortAlgorithm. You can do the same thing for your sort algorithms, as long
    // as your sort algorithms return a void and have parameters: (int array[], int size).

    cout << endl << setw(AlgorithmNameWidth) << left << "bubble sort";
    for (int testCount = 0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
        cout << setw(DurationWidth) << right << testSortAlgorithm(bubbleSort, array, testSizes[testCount]);

    cout << endl << setw(AlgorithmNameWidth) << left << "insertion sort";
    for (int testCount = 0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
        cout << setw(DurationWidth) << right << testSortAlgorithm(insertionSort, array, testSizes[testCount]);

    // Here, the provided linear search is tested...
    cout << endl << setw(AlgorithmNameWidth) << left << "linear search";
    for (int testCount = 0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
        cout << setw(DurationWidth) << right << testLinearSearch(array, testSizes[testCount]);

    cout << endl << setw(AlgorithmNameWidth) << left << "binary search";
    for (int testCount = 0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
        cout << setw(DurationWidth) << right << testBinarySearch(array, testSizes[testCount]);
    cout << endl;
}


int main() {
    srand(time(0));  // seed the random number generator only once.

    // When first implementing your algorithm, test it on a very small array.
    const int defaultsmallArray[] = { 5, 7, 2, 8, 9, 1 }; // for testing purposes
    const int SMALLSIZE = sizeof(defaultsmallArray) / sizeof(defaultsmallArray[0]);
    int smallArray[SMALLSIZE]{}; // for testing purposes, resort several times

    cout << "Test sorting algorithms on small array:\n\n";
    for (int i{}; i < SMALLSIZE; ++i) smallArray[i] = defaultsmallArray[i]; // initialize smallArray
    showArray(smallArray, SMALLSIZE, "Selection sort start: smallArray is: ");
    selectionSort(smallArray, SMALLSIZE, true); // true means to show details
    showArray(smallArray, SMALLSIZE, "Selection sort stop:  smallArray is: ");
    cout << ((verifySorted(smallArray, SMALLSIZE)) ?
        "verified: smallArray is sorted.\n" :
        "Ooops!!!: smallArray is NOT sorted.\n");

    // When first implementing your algorithm, test it
    // on a very small array. Test your new sorts on smallArray below.
    for (int i{}; i < SMALLSIZE; ++i) smallArray[i] = defaultsmallArray[i]; // initialize smallArray
    showArray(smallArray, SMALLSIZE, "\nbubbleSort start: smallArray is: ");
    bubbleSort(smallArray, SMALLSIZE, true); // true means to show details
    showArray(smallArray, SMALLSIZE, "bubbleSort stop:  smallArray is: ");
    cout << ((verifySorted(smallArray, SMALLSIZE)) ?
        "verified: smallArray is sorted.\n" :
        "Ooops!!!: smallArray is NOT sorted.\n");

    for (int i{}; i < SMALLSIZE; ++i) smallArray[i] = defaultsmallArray[i]; // initialize smallArray
    showArray(smallArray, SMALLSIZE, "\ninsertion sort start: smallArray is: ");
    insertionSort(smallArray, SMALLSIZE, true); // true means to show details
    showArray(smallArray, SMALLSIZE, "insertion sort stop:  smallArray is: ");
    cout << ((verifySorted(smallArray, SMALLSIZE)) ?
        "verified: smallArray is sorted.\n" :
        "Ooops!!!: smallArray is NOT sorted.\n");

    const int BIGSIZE = 50000;
    int bigArray[BIGSIZE];
    float duration = 0.0; // time in milliseconds

    // Startup code performs a single test run using the full size of bigArray
    duration = testSortAlgorithm(selectionSort, bigArray, BIGSIZE);
    cout << fixed << setprecision(2);
    cout << "\nSelection sort on bigArray took: "
        << setw(7) << duration << " milliseconds." << endl;

    duration = testLinearSearch(bigArray, BIGSIZE);
    cout << "Linear search  of bigArray took: "
        << setw(7) << duration << " milliseconds.\n\n";

    // Test the algorithms on many ever longer list of numbers. Only one
    // array is needed.  Lengths of 1000, 5000, 10000, 20000, 30000,
    // 40000, 50000 are tested.
    testAlgorithms(bigArray, BIGSIZE);
    cout << endl;

    return 0;
} // end of main

void bubbleSort(int array[], int size, bool verbose = false) {
    bool madeSwap = true;
    int temp, a, b{ 0 };
    for (int maxElement{ size - 1 }; maxElement > 0 && madeSwap; maxElement--)
    {
        madeSwap = false;   // madeSwap is needed to enter loop, but no swap is made yet
        for (int index{ 0 }; index < maxElement; index++)
        {
            // if item to the left is greater than item to the right,
            // swap them, do this for whole array. (this equals one pass)
            if (array[index] > array[index + 1])
            {
                temp = array[index];
                array[index] = array[index + 1];
                array[index + 1] = temp;
                madeSwap = true;
                if (verbose)
                {
                    cout << "  pass #:" << size - maxElement; 
                    showArray(array, size);
                }
            }
        }
    }
}

void insertionSort(int array[], int size, bool verbose = false) 
{
    int index, key, leftItemIndex;
    for (index = 1; index < size; index++)
    {
        key = array[index];
        leftItemIndex = index - 1;

        // if item to the right of an item is smaller, move it down
        // until it is bigger than the item to the left
        while (leftItemIndex >= 0 && array[leftItemIndex] > key)
        {
            array[leftItemIndex + 1] = array[leftItemIndex];
            leftItemIndex--;
        }
        if (verbose)
        {
            cout << "  insertion:";
            showArray(array, size);
        }
        array[leftItemIndex + 1] = key;
    }
}

// Your new search algorithm cannot be linear search, which is provided here.
bool linearSearchArray(int array[], int size, int target, int& position) {
    for (int i = 0; i < size; ++i)
        if (array[i] == target) // found it!
        {
            position = i; return true;
        }
    position = -1;
    return false;
}

bool binarySearchArray(int array[], int size, int target, int& position) 
{
    int first{ 0 };
    int last{ size - 1 };
    int middle{ -1 };
    position = -1;
    bool found = false;
    // if first > last, the item is non-existent
    while (!found && first <= last)
    {
        // calc middle of relative first and last
        middle = (first + last) / 2;
        // if the middle is the target, return the pos
        if (array[middle] == target)
        {
            found = true;
            position = middle;
            return true;
        }
        // if it is not, and it is less than the middle, move the end to the middle - 1
        else if (array[middle] > target)
            last = middle - 1;
        else
            first = middle + 1; // if target is greater, the beginning is now the old middle (excluding middle)
    }
    return false;
}

// This is a selection sort from a concise algorithm encyclopedia.
// This code is VERY CRYPTIC! Not useful for learning. Not called.
// If your algorithms look like this, you will lose points!!!
void selectionSortConcise(int array[], int size) {
    int i, idx, val;
    for (i = 0; i < (size - 1); i++) {
        idx = i;
        val = array[i];
        for (int j = i + 1; j < size; j++) {
            if (array[j] < val) {
                val = array[j];
                idx = j;
            }
        }
        array[idx] = array[i];
        array[i] = val;
    }
}

// Your new sort algorithm cannot be selection sort, which is provided.
// This is the selection sort from our textbook, not called.
void selectionSortTextbook(int array[], int size) {
    int startScan, minIndex, minValue;
    for (startScan = 0; startScan < (size - 1); startScan++) {
        minIndex = startScan;
        minValue = array[startScan];
        for (int index = startScan + 1; index < size; index++) {
            if (array[index] < minValue) {
                minValue = array[index];
                minIndex = index;
            }
        }
        array[minIndex] = array[startScan];
        array[startScan] = minValue;
    }
}

// This selection sort is described in great detail, as you should do for this lab
// As an option, it displays details of its operation for each pass.
void selectionSort(int array[], int size, bool verbose = false) {
    int minIndexSoFar = 0, minValueSoFar{ array[0] };
    for (int unsortedIndex = 0; unsortedIndex < (size - 1); unsortedIndex++) {
        // The outer loop looks at unsorted data, which is initially the whole array.
        // Gradually, a smaller and smaller portion of the array remains unsorted.
        minIndexSoFar = unsortedIndex;
        minValueSoFar = array[unsortedIndex];
        for (int seekMinIndex = unsortedIndex + 1; seekMinIndex < size; seekMinIndex++) {
            // the inner loop seeks the smallest value possible in the
            // remaining unsorted portion of the array.
            if (array[seekMinIndex] < minValueSoFar) {
                // found a smaller value than I had before, save it for now
                if (verbose)
                    cout << "  prev min value: " << minValueSoFar << " at offset: " << minIndexSoFar;
                minValueSoFar = array[seekMinIndex];
                minIndexSoFar = seekMinIndex;
                if (verbose)
                    cout << "; yet smaller value: " << minValueSoFar << " at offset: " << minIndexSoFar << endl;
            }
        }
        // The smallest value in the unsorted portion of the array has been found.
        // Replace the older minimum value, which wasn't really the actual minimum
        // value, with the new, real minimum value which was just found.
        array[minIndexSoFar] = array[unsortedIndex];
        array[unsortedIndex] = minValueSoFar;
        if (verbose) {
            cout << "  swap prev min value: " << array[minIndexSoFar]
                << " with new min value: " << array[unsortedIndex] << endl;
            cout << "After pass " << unsortedIndex << " the array is: ";
            showArray(array, size);
            cout << endl;
        }

        // ... continue seeking the minimum value in the smaller remaining portion.
    }
}

/*
Test sorting algorithms on small array:

Selection sort start: smallArray is:  5 7 2 8 9 1
  prev min value: 5 at offset: 0; yet smaller value: 2 at offset: 2
  prev min value: 2 at offset: 2; yet smaller value: 1 at offset: 5
  swap prev min value: 5 with new min value: 1
After pass 0 the array is:  1 7 2 8 9 5

  prev min value: 7 at offset: 1; yet smaller value: 2 at offset: 2
  swap prev min value: 7 with new min value: 2
After pass 1 the array is:  1 2 7 8 9 5

  prev min value: 7 at offset: 2; yet smaller value: 5 at offset: 5
  swap prev min value: 7 with new min value: 5
After pass 2 the array is:  1 2 5 8 9 7

  prev min value: 8 at offset: 3; yet smaller value: 7 at offset: 5
  swap prev min value: 8 with new min value: 7
After pass 3 the array is:  1 2 5 7 9 8

  prev min value: 9 at offset: 4; yet smaller value: 8 at offset: 5
  swap prev min value: 9 with new min value: 8
After pass 4 the array is:  1 2 5 7 8 9

Selection sort stop:  smallArray is:  1 2 5 7 8 9
verified: smallArray is sorted.

bubbleSort start: smallArray is:  5 7 2 8 9 1
  pass #:1 5 2 7 8 9 1
  pass #:1 5 2 7 8 1 9
  pass #:2 2 5 7 8 1 9
  pass #:2 2 5 7 1 8 9
  pass #:3 2 5 1 7 8 9
  pass #:4 2 1 5 7 8 9
  pass #:5 1 2 5 7 8 9
bubbleSort stop:  smallArray is:  1 2 5 7 8 9
verified: smallArray is sorted.

insertion sort start: smallArray is:  5 7 2 8 9 1
  insertion: 5 7 2 8 9 1
  insertion: 5 5 7 8 9 1
  insertion: 2 5 7 8 9 1
  insertion: 2 5 7 8 9 1
  insertion: 2 2 5 7 8 9
insertion sort stop:  smallArray is:  1 2 5 7 8 9
verified: smallArray is sorted.

Selection sort on bigArray took: 2748.00 milliseconds.
Linear search  of bigArray took:    0.11 milliseconds.

Algorithm             1000      5000     10000     20000     30000     40000     50000
================   =======   =======   =======   =======   =======   =======   =======
selection sort        1.00     24.00     97.00    407.00    923.00   1674.00   2618.00
bubble sort           2.00     62.00    250.00   1017.00   2301.00   4134.00   6439.00
insertion sort        0.00     14.00     56.00    218.00    487.00    875.00   1372.00
linear search         0.00      0.01      0.02      0.04      0.06      0.09      0.11
binary search         0.00      0.00      0.00      0.00      0.00      0.00      0.00


C:\Users\rshar\Desktop\Projects\School\COSC-1337\Debug\DL3_L9_Riccio.exe (process 7184) exited with code 0.
To automatically close the console when debugging stops, enable Tools->Options->Debugging->Automatically close the console when debugging stops.
Press any key to close this window . . .
*/